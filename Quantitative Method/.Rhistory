data("Journals")
#str(Journals)
#View(Journals)
Journals
knitr::opts_chunk$set(echo = TRUE)
journals %>%
lm(log(subs)~log(citeprice),data=.) -> model_1
knitr::opts_chunk$set(echo = TRUE)
library(dpltr)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(dplyr)
journals %>%
lm(log(subs)~log(citeprice),data=.) -> model_1
knitr::opts_chunk$set(echo = TRUE)
data("Journals")
#str(Journals)
#View(Journals)
Journals
library("AER")
library("ggplot2")
library("dplyr")
library("knitr")
library("AER")
library("ggplot2")
library("dplyr")
library("knitr")
data("Journals")
#str(Journals)
#View(Journals)
Journals
knitr::opts_chunk$set(echo = TRUE)
data("Journals")
#str(Journals)
#View(Journals)
Journals
Journals %>% mutate(citeprice=price/citations) -> journals
#journals
summary(journals) #用來看資料特徵
#price，圖書館訂閱某期刊的價格
#citations，某期刊被引用的次數
#citeprice，期刊引用單價
# 引用單價citeprice，如何影響訂閱subs，進到一個類似x影響y，需求的概念
# -0.42是correlation
#
library(psych)
# journals %>%
#   select(citeprice,subs) %>%
#   pairs.panels()
journals
journals$subs
# 更理想的寫法，畢竟select這個函數一定有人用過，而且隸屬於兩個以上的套件
journals %>%
dplyr::select(citeprice,subs) %>% #select: extract column by name
pairs.panels()
journals %>%
dplyr::select(citeprice,subs) %>%
dplyr::mutate_all(log) %>% #取log使他較接近常態分配，OLS迴歸斜率也較清楚。
pairs.panels()
# 判斷變數是否為數值類別，先建立函數功能。
is_numeric<-function(x) all(is.numeric(x))
# 計算數數與citeprice的相關係數，先建立函數功能，那要另外建立，是因為有一個citeprice這個變數，我想要先訂下來。
cor_citeprice<-function(x) cor(x,journals$citeprice)
journals %>%
select_if(is_numeric) %>%
summarise_all(cor_citeprice) %>% #summarise是接近敘述統計量的意思
kable() #kable讓印的表變得比較好看
#回去寫：佐證foundingyear和subs的立足點不同的佐證。correlation
library(dplyr)
cor_subs <- function(x){
cor(x,journals$subs)
}
journals %>%
select_if(is_numeric) %>%
summarise_all(cor_subs)
#cor(foundingyear, subs) = -0.4073721
#cor(foundingyear, citeprice) = 0.3102098
#cor(citeprice, subs) = -0.4195314
journals %>%
lm(log(subs)~log(citeprice),data=.) #data=.意思是指若在pipe裡面，如果你要放進去的地方，不是在第一個參數的位置。那就可以點，去告訴電腦去把他放到恰當的位置。
#在R裡面，~是建構一個formula，是可以存起來的。那在實證分析上，會傾向先把迴歸式建好，比較不會一直重複打。
journals %>%
lm(log(subs)~log(citeprice)+foundingyear,data=.)
journals %>%
lm(log(subs)~log(citeprice)+foundingyear,data=.)
library(dplyr)
journals %>%
lm(log(subs)~log(citeprice),data=.) -> model_1
journals %>%
lm(log(subs)~log(citeprice)+foundingyear,data=.) -> model_2
model_1
model_2
knitr::opts_chunk$set(echo = TRUE)
library(sandwich) #for standard error(就是standard error公式的一個形態，兩端相同，只有中間不同。)
library(lmtest)
library(stargazer)
#使用vcovHC函數來計算HC1型的異質變異
#（即橫斷面資料且符合隨機抽樣下，的線性迴歸模型）
coeftest(model_1, vcov. = vcovHC, type="HC1") -> model_1_coeftest
coeftest(model_2, vcov. = vcovHC, type="HC1") -> model_2_coeftest
# vcov. = vcovHC, type="HC1" 是固定的，就是因為他是橫斷面且符合隨機抽樣的類型。他的非對角線都是0，那HC1、HC2是不同的資料型態。遇到就會比較知道。
model_1_coeftest
model_2_coeftest
stargazer(model_1, model_2,
se=list(model_1_coeftest[,"Std. Error"], model_2_coeftest[,2]),
type="text",
align=TRUE)
#se 指定的standard error算法。se=list(...)不要動。
#[,"Std. Error"]和[,2]的寫法是一樣的目的。寫法不同。
#type="text" 也可以改成"html"
#align就是讓他排版就好看而已。
#查coeftest的help
#查stargazer的help
model_1_coeftest
knitr::opts_chunk$set(echo = TRUE)
model_2_coeftest
model_1_coeftest
model_2_coeftest
knitr::opts_chunk$set(echo = TRUE)
stargazer(model_1, model_2,
se=list(model_1_coeftest[,"Std. Error"], model_2_coeftest[,2]),
type="text",
align=TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
cor_subs <- function(x){
cor(x,journals$subs)
}
journals %>%
select_if(is_numeric) %>%
summarise_all(cor_subs)
#cor(foundingyear, subs) = -0.4073721
#cor(foundingyear, citeprice) = 0.3102098
#cor(citeprice, subs) = -0.4195314
knitr::opts_chunk$set(echo = TRUE)
journals %>% select(foundingyear, subs) %>% pairs.panels()
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
wage1
wage1 %>% select(educ, wage) %>% psych::pairs.panels()
#由目前的圖來看，對wage取log叫好，因為可以使其更接近常態分配。
wage1 %>% select(educ, lwage) %>% psych::pairs.panels()
wage1 %>%
lm(formula = lwage~educ) #這邊因為formula有設定好。那data就會放到第二個參數，剛好是data，也就可以跑了。
#迴歸式：lwage = 0.58377 + 0.08274educ + epislon
wage1 %>% select(nonwhite, lwage) %>% psych::pairs.panels() #-0.04
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(numdep, lwage) %>% psych::pairs.panels() #-0.10
#類別資料，(0,1) (0,1,2,3,4)這種也可以取log嗎？（或者說取log有意義嗎？
wage1 %>% lm(lwage~educ+female, data = .)
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
wage1
wage1 %>% select(educ, wage) %>% psych::pairs.panels()
#由目前的圖來看，對wage取log叫好，因為可以使其更接近常態分配。
wage1 %>% select(educ, lwage) %>% psych::pairs.panels()
wage1 %>%
lm(formula = lwage~educ) #這邊因為formula有設定好。那data就會放到第二個參數，剛好是data，也就可以跑了。
#迴歸式：lwage = 0.58377 + 0.08274educ + epislon
wage1 %>% select(nonwhite, lwage) %>% psych::pairs.panels() #-0.04
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(numdep, lwage) %>% psych::pairs.panels() #-0.10
#類別資料，(0,1) (0,1,2,3,4)這種也可以取log嗎？（或者說取log有意義嗎？
wage1 %>% lm(lwage~educ+female, data = .)
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage)) -> wageforUniTreatment
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
# 不曉得有沒有更好的cut的表達方式？
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
wage1 %>%
select(wage,educ) %>%
psych::pairs.panels()
boxplot(wage1$educ ~ wage1$smsa, xlab="smsa", ylab="educ")
wage1 %>% group_by(smsa) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
boxplot(wage1$educ ~ wage1$female, xlab="female", ylab="educ")
wage1 %>% group_by(female) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
summary(lm(log(wage1$wage)~ wage1$educ + wage1$female + wage1$smsa))
wage1 %>% select(nonwhite, lwage) %>% psych::pairs.panels() #-0.04
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(numdep, lwage) %>% psych::pairs.panels() #-0.10
#類別資料，(0,1) (0,1,2,3,4)這種也可以取log嗎？（或者說取log有意義嗎？
wage1 %>% filter(educ==12) %>% nrow()
wage1 %>% filter(educ==12)
wage1 %>% filter(educ==12) %>% nrow()
wage1 %>% filter(educ>=13 & educ <= 15) %>% nrow()
wage1 %>% filter(educ==16) %>% nrow()
wage1 %>% filter(educ>=16) %>% nrow() #68
wage1 %>% filter(educ==16) %>% nrow() #68
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage)) -> wageforUniTreatment
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
# 不曉得有沒有更好的cut的表達方式？
8.041618 * 68/(68+113) + 6.03 * 113/(99+113) - 5.371364	-> x
x
8.041618 * 68/(68+113) + 6.03 * 113/(99+113) - 5.371364
8.041618 * 68/(68+113) + 6.03 * 113/(68+113) - 5.371364
8.041618 * 68/(68+113) + 6.03 * 113/(68+113) - 5.371364 -> x
8.041618 * 68/(68+113) + 6.03 * 113/(68+113) - 5.371364 -> x
x
View(wage1)
View(wage1)
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage)) -> wageforUniTreatment
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
# 不曉得有沒有更好的cut的表達方式？
boxplot(wage1$educ ~ wage1$smsa, xlab="smsa", ylab="educ")
wage1 %>% group_by(smsa) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
boxplot(wage1$educ ~ wage1$smsa, xlab="smsa", ylab="educ")
boxplot(wage1$educ ~ wage1$smsa, xlab="smsa", ylab="educ")
wage1 %>% group_by(smsa) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
boxplot(wage1$educ ~ wage1$female, xlab="female", ylab="educ")
wage1 %>% group_by(female) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
summary(lm(log(wage1$wage)~ wage1$educ + wage1$female + wage1$smsa))
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage)) -> wageforUniTreatment
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
wage1
wage1 %>% select(educ, wage) %>% psych::pairs.panels()
#由目前的圖來看，對wage取log叫好，因為可以使其更接近常態分配。
wage1 %>% select(educ, lwage) %>% psych::pairs.panels()
wage1 %>%
lm(formula = lwage~educ) #這邊因為formula有設定好。那data就會放到第二個參數，剛好是data，也就可以跑了。
#迴歸式：lwage = 0.58377 + 0.08274educ + epislon
wage1 %>% select(nonwhite, lwage) %>% psych::pairs.panels() #-0.04
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(numdep, lwage) %>% psych::pairs.panels() #-0.10
#類別資料，(0,1) (0,1,2,3,4)這種也可以取log嗎？（或者說取log有意義嗎？
wage1 %>% lm(lwage~educ+female, data = .)
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage)) -> wageforUniTreatment
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
# 不曉得有沒有更好的cut的表達方式？
wage1 %>%  group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage))
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage), n=n()) -> wageforUniTreatment
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
#另一個寫法，但是會有一組其餘部分的NA
# wage1 %>%  group_by(cut(educ, c(11, 12, 15, 16))) %>%
#   summarise(avgwage = mean(wage))
# 不曉得有沒有更好的cut的表達方式？
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, n=n()))
wageforUniTreatment
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, w=c(113, 68)))
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage), n=n()) -> wageforUniTreatment #n=n()是可以計算樣本數
wageforUniTreatment
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, w=c(113, 68)))
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage), n=n()) -> wageforUniTreatment #n=n()是可以計算樣本數
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, w=c(113, 68)))
boxplot(wage1$educ ~ wage1$smsa, xlab="smsa", ylab="educ")
wage1 %>% group_by(smsa) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
wage1 %>%
select(wage,educ) %>%
psych::pairs.panels()
wage1 %>%
lm(formula = lwage~educ) #這邊因為formula有設定好。那data就會放到第二個參數，剛好是data，也就可以跑了。
#迴歸式：lwage = 0.58377 + 0.08274educ + epislon
boxplot(wage1$educ ~ wage1$smsa, xlab="smsa", ylab="educ")
wage1 %>% group_by(smsa) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
wage1 %>% select(nonwhite, lwage) %>% psych::pairs.panels() #-0.04
wage1 %>% select(nonwhite, educ) %>% psych::pairs.panels()
wage1 %>% select(femalem educ) %>% psych::pairs.panels()
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(femalem, educ) %>% psych::pairs.panels()
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(female, educ) %>% psych::pairs.panels()
boxplot(wage1$educ ~ wage1$female, xlab="female", ylab="educ")
wage1 %>% group_by(female) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
wage1 %>% select(numdep, educ) %>% psych::pairs.panels() #-0.10
### 答案訂正方向：
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, w=c(113, 68)))
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage), n=n()) -> wageforUniTreatment #n=n()是可以計算樣本數，就是求平均的那個，分母的n
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]"))
### 答案訂正方向：
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, w=c(113, 68)))
#%in% operator是指：是否包含...並且回傳T F
#所以這邊就是是否包含"字串內容"，會用字串主要原因是因為類別變數的關係。
#若不用weighted.mean的方式，就變得要
6.030000*(113/113+68) + 8.041618*(68/113+68) - 5.371364
6.030000*(113/113+68)
### 答案訂正方向：
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, w=c(113, 68)))
#%in% operator是指：是否包含...並且回傳T F
#所以這邊就是是否包含"字串內容"，會用字串主要原因是因為類別變數的關係。
#若不用weighted.mean的方式，就變得要
6.030000*(113/(113+68))+ 8.041618*(68/(113+68)) - 5.371364
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
wage1
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
wage1
wage1 %>% select(educ, wage) %>% psych::pairs.panels()
#由目前的圖來看，對wage取log叫好，因為可以使其更接近常態分配。
wage1 %>% select(educ, lwage) %>% psych::pairs.panels()
wage1 %>%
lm(formula = lwage~educ) #這邊因為formula有設定好。那data就會放到第二個參數，剛好是data，也就可以跑了。
#迴歸式：lwage = 0.58377 + 0.08274educ + epislon
wage1 %>% select(nonwhite, lwage) %>% psych::pairs.panels() #-0.04
wage1 %>% select(nonwhite, educ) %>% psych::pairs.panels() #-0.08
#其實你可以知道的是基本上（是不是白人）不會照成選擇偏誤。因為nonwhite對於educ受教育的解釋能力（相關係數，線性關係的能度）很低。對被解釋變數的lwage也是一樣的。
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(female, educ) %>% psych::pairs.panels() #-0.09
#由這邊可以看到性別和受教育的相關程度偏低，但是性別確實會影響工資。造成選擇偏誤的故事背後的數據力可能還不夠充分。因為看起來，是否為女性的立足點，不至於影響他是否接受treatment
#可以參考學長的做法。（下個chunk)
boxplot(wage1$educ ~ wage1$female, xlab="female", ylab="educ")
wage1 %>% group_by(female) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
wage1 %>% select(numdep, lwage) %>% psych::pairs.panels() #-0.10
wage1 %>% select(numdep, educ) %>% psych::pairs.panels() #-0.22
#孩子的個數也還好。他確實會造成立足點是否接受treatment的不同（孩子越多真的越沒空進修。但是他不見得會同時影響工資。
wage1 %>% lm(lwage~educ+female, data = .)
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage), n=n()) -> wageforUniTreatment #n=n()是可以計算樣本數，就是求平均的那個，分母的n
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
### 答案訂正方向：
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, w=c(113, 68)))
#%in% operator是指：是否包含...並且回傳T F
#所以這邊就是是否包含"字串內容"，會用字串主要原因是因為類別變數的關係。
#若不用weighted.mean的方式，就變得要
6.030000*(113/(113+68))+ 8.041618*(68/(113+68)) - 5.371364
#你的程式答案
rm(list=ls())
library(dplyr)
library(psych)
library(haven)
wage1 <- read_dta("http://fmwww.bc.edu/ec-p/data/wooldridge/wage1.dta")
wage1
wage1 %>% select(educ, wage) %>% psych::pairs.panels()
#由目前的圖來看，對wage取log叫好，因為可以使其更接近常態分配。
wage1 %>% select(educ, lwage) %>% psych::pairs.panels()
wage1 %>%
lm(formula = lwage~educ) #這邊因為formula有設定好。那data就會放到第二個參數，剛好是data，也就可以跑了。
#迴歸式：lwage = 0.58377 + 0.08274educ + epislon
wage1 %>% select(nonwhite, lwage) %>% psych::pairs.panels() #-0.04
wage1 %>% select(nonwhite, educ) %>% psych::pairs.panels() #-0.08
#其實你可以知道的是基本上（是不是白人）不會照成選擇偏誤。因為nonwhite對於educ受教育的解釋能力（相關係數，線性關係的能度）很低。對被解釋變數的lwage也是一樣的。
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(female, educ) %>% psych::pairs.panels() #-0.09
#由這邊可以看到性別和受教育的相關程度偏低，但是性別確實會影響工資。造成選擇偏誤的故事背後的數據力可能還不夠充分。因為看起來，是否為女性的立足點，不至於影響他是否接受treatment
#可以參考學長的做法。（下個chunk)
boxplot(wage1$educ ~ wage1$female, xlab="female", ylab="educ")
wage1 %>% group_by(female) %>%
summarise(mean(educ,na.rm=T),sd(educ,na.rm=T))
wage1 %>% select(numdep, lwage) %>% psych::pairs.panels() #-0.10
wage1 %>% select(numdep, educ) %>% psych::pairs.panels() #-0.22
#孩子的個數也還好。他確實會造成立足點是否接受treatment的不同（孩子越多真的越沒空進修。但是他不見得會同時影響工資。
wage1 %>% lm(lwage~educ+female, data = .)
wage1 %>%
filter(educ >= 12 & educ <= 16) %>%
group_by(cut(educ, c(11, 12, 15, 16))) %>%
summarise(avgwage = mean(wage), n=n()) -> wageforUniTreatment #n=n()是可以計算樣本數，就是求平均的那個，分母的n
names(wageforUniTreatment)[1] <- "EducInterval"
wageforUniTreatment
### 答案訂正方向：
wageforUniTreatment %>% filter(EducInterval %in% c("(12,15]","(15,16]")) %>%
summarise(weightavgwage = weighted.mean(avgwage, w=c(113, 68)))
#%in% operator是指：是否包含...並且回傳T F
#所以這邊就是是否包含"字串內容"，會用字串主要原因是因為類別變數的關係。
#若不用weighted.mean的方式，就變得要
6.030000*(113/(113+68))+ 8.041618*(68/(113+68)) - 5.371364
wage1 %>% select(nonwhite, lwage) %>% psych::pairs.panels() #-0.04
wage1 %>% select(female, lwage) %>% psych::pairs.panels() #-0.37
wage1 %>% select(numdep, lwage) %>% psych::pairs.panels() #-0.10
#類別資料，(0,1) (0,1,2,3,4)這種也可以取log嗎？（或者說取log有意義嗎？
knitr::opts_chunk$set(echo = TRUE,warning=F,message=F)
library(readr)
labordata <- read_csv("http://people.stern.nyu.edu/wgreene/Econometrics/cornwell&rupert.csv")
labordata
labordata %>% filter(YEAR==7)
library(dplyr)
library(magrittr)
labordata %>% filter(YEAR==7)
plot(WKS, LWAGE)
labordata %>% plot(WKS, LWAGE)
plot(labordata$WKS, labordata$LWAGE)
plot(labordata$WKS, labordata$LWAGE, xlab = "每週工時", ylab = "薪資")
plot(labordata$WKS, labordata$LWAGE, xlab = "workinghour/week", ylab = "salary")
plot(labordata$WKS, labordata$LWAGE, xlab = "WKS", ylab = "LWAGE")
plot(labordata$WKS, labordata$LWAGE, xlab = "WKS", ylab = "LWAGE")
plot(labordata$LWAGE, labordata$WKS, xlab = "LWAGE", ylab = "WKS")
?union
?union
(x <- c(sort(sample(1:20, 9)), NA))
(y <- c(sort(sample(3:23, 7)), NA))
union(x, y)
x <- 1:10
y <- 2:13
union(x, y)
labordata %>% lm(formula = WKS ~ LWAGE)
lab
labordata
# 我有點不太懂要用union，取連集要怎麼做到。
labordata %>% filter(UNION == 1) %>% summarise(mean1 = avg(LWAGE))
# 我有點不太懂要用union，取連集要怎麼做到。
labordata %>% filter(UNION == 1) %>% summarise(mean1 = mean(LWAGE))
labordata %>% filter(UNION == 2) %>% summarise(mean1 = mean(LWAGE))
labordata %>% filter(UNION == 0) %>% summarise(mean1 = mean(LWAGE))
# 我有點不太懂要用union，取連集要怎麼做到。
labordata %>% filter(UNION == 1) %>% summarise(mean1 = mean(LWAGE))
labordata %>% filter(UNION == 0) %>% summarise(mean1 = mean(LWAGE))
lm1 <- labordata %>% lm(formula = WKS ~ LWAGE)
LM1
lm1
View(labordata)
View(labordata)
library(sandwich)
library(lmtest)
library(stargazer)
lm1 <- labordata %>% lm(formula = WKS ~ LWAGE)
lm2 <- labordata %>% lm(formula = WKS ~ LWAGE + ED + UNION + FEM)
library(sandwich)
library(lmtest)
library(stargazer)
lm1 <- labordata %>% lm(formula = WKS ~ LWAGE)
lm2 <- labordata %>% lm(formula = WKS ~ LWAGE + ED + UNION + FEM)
stargazer(lm1, lm2, type = "html")
stargazer(lm1, lm2, type = "text")
stargazer(lm1, lm2, type = "html")
stargazer(lm1, lm2, type = "text")
